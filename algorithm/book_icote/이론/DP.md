# DP

31-36번 문제

## 개요

- 한번 해결된 부분 문제의 정답을 메모리에 기록하여, 한 번 계산한 답은 다시 계산하지 않도록 하는 문제 해결 기법
- 점화식을 그대로 코드로 옮겨서 구현한다.
  - 점화식은 인접한 항등 사이의 관계식을 의미한다.
- 탐다운: 재귀 - 큰문제 -> 작은문제 호출로 해결
- 보텀업: 작은문제 반복 -> 큰문제 해결

## 유형

## 문제유형

- 31번: m번 이동함 -> m열중 정답, 0열은 초기값
  - 2번째 열부터 반복하며 이동 가능한 연산 중 최대값으로 갱신
  - m열중 최대값이 정답
- 32번: 왼쪽 대각선 혹은 오른쪽 대각선 = 인덱스-1 또는 +0
- 33번: 점화식= i번째 날부터 마지막 날까지 낼수 있는 최대 이익 = `p[i]+dp[t[i]+i] 단 t[i]+1 <= n`
  - 최소=마지막 -> 마지막부터 역순으로 반복
- 34번: 가장 긴 오름차순 수열 문제로 변환(배열 뒤집기)
  - 점화식=array[i]를 마지막 원소로 가지는 부분 수열의 최대 길이
  - `0<=j<i, dp[i] = max(dp[i], dp[j]+1) if array[j]<array[i])`
- 35번: i번째 못생긴수를 갱신해 나가기
  - 1번째 못생긴수 = 1
  - 2,3,5의 1번째 배수는 2,3,5
  - 2번째 배수는 4,6,10
  - 2,3,5의 다음 배수값과 현재 몇번째 배수인지를 저장
- 36번: 최소값 = 빈문자열에서 연산 => 0행,열 - 인덱스+1만큼 연산 필요
  - 점화식: 행열 문자 같다면 왼쪽위 숫자 삽입
  - 다르다면 행기준 삽입(왼쪽), 삭제(위), 교체(왼쪽위) 중 최초값 +1로 업데이트
