# 그래프 이론

41-45번 문제

## 개요

### 서로소 집합

- 서로소 집합은 공통 원소가 없는 두 집합이다. 집합 간의 관계를 파악할 때 사용한다.
- 연산
  - find: 자신이 속한 노드를 재귀적으로 찾음
  ```
  # 부모를 찾고 테이블에 저장
  def find(parent, x):
    if parent[x] != x:
        parent[x] = find(parent, parent[x])
    return parent[x]
  ```
  - union: 두 노드의 루트를 비교하여 값이 큰 노드의 루트를 작은 노드로 설정함으로서 합집합 연산을 수행함
  ```
  def union(parent, a, b):
    a = find(parent, a)
    b = find(parent, b)
    # 값이 큰 노드의 부모를 작은 노드로 설정
    if a < b:
        parent[b] = a
    else:
        parent[a] = b
  ```
- 신장 트리, 크루스칼 알고리즘에 활용

### 신장 트리

- 하나의 그래프가 모든 노드를 포함하는 부분 그래프를 의미함
- 모든 섬을 도로를 이용해 연결하는 문제
- 간선에 대한 서로소 집합 여부 확인

### 크루스칼 알고리즘

- 가능한 최소 비용의 신장 트리를 찾아주는 알고리즘
- 모든 섬을 도로를 이용해 최소의 비용으로 연결하는 문제
- 구현 포인트
  - 간선에 오름차순 정렬 수행 후, 비용 낮은 순서대로 집합에 포함시킴(그리디)

### 위상 정렬

- 방향 그래프의 모든 노드들을 방향성에 거스르지 않도록 순서대로 나열하는 정렬 기법
- 선수 과목을 고려한 학습 순서 등
- 연산
  - 노드간 연결 여부 조회 필요 -> 인접행렬 방식으로 간선 업데이트
  - 동시에, 진입 차수 테이블에 업데이트
  - 노드 개수 만큼 진입차수 0인 노드를 반복함
  - 큐를 이용하여 반복할 노드를 저장
  - 매 반복시 큐의 길이가 1이면 유효한 위상정렬
    - 길이 > 1 : 여러 가지가 존재하는 그래프, 길이 = 0 : 사이클이 존재하는 그래프
  - 큐에서 꺼낸 노드에서 간선으로 연결된 노드에 대해 진입 차수를 -1 연산하고 큐에 추가한다.(큐에서 꺼낸 노드의 모든 연결을 해제한다.)

## 유형

## 문제 유형

- 41번: 모든 여행지 경로에 대해 서로소 집합 연산을 수행하여 같은 집합인지 확인함
  - 같은 집합이 아닐 경우 여행할 수 없음
- 42번: 탑승 가능한 위치 1에서 g까지. 한곳에 도킹해야함
  - i에 도킹하면 i와 i-1을 합집합 연산
  - i의 루트가 0이면(i가 0과 같은 집합이면) 더이상 빈 공간이 없으므로 운행이 종료됨
- 43번: 크루스칼 알고리즘
  - 간선에 오름차순 정렬 수행 후, 비용 낮은 순서대로 집합에 포함시킴
- 44번: 크루스칼 알고리즘
  - 거리 = `min(|x1-x2|,|y1-y2|,|z1-z2|)`
  - x,y,z 좌표 축에 대해 거리 비교 -> 도시와 한 축만 남기고 정렬하면, 해당 축에 대해 일직선 상에 정렬할 수 있으며 인접한 두 도시는 거리가 최소값이다.
  - 각 축별로 간선의 거리를 계산하여 모은뒤 정렬하면, 두 도시에 대해 최소 거리 순으로 얻을 수 있다.
  - 모든 간선에 대해 두 도시가 연결되었는지 루트를 확인하여 다른 집합이면 합집합 연산을 수행한다. 이 방법으로 모든 도시를 연결하는 최소 거리를 얻을수 있다.
- 45번: 위상 정렬
  - 위상 정렬 방법대로 작년 점수를 기준하여 인접행렬과 진입차수 테이블을 설정함
  - 변경된 순서에 대해 a를 진출 노드, b를 진입 노드로 설정한 후, 순서를 바꾸는 연산을 수행한다.
    - a의 진입차수를 +1, a->b 연결을 해제한다.
    - b의 진입차수를 -1, b->a 연결을 수행한다.
