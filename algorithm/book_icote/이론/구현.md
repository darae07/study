# 구현

7-14번 문제

## 개요

- 머릿속에 있는 알고리즘을 정확하고 빠르게 구현하는 과정
- 동일한 알고리즘이라면 더 간결하고 효율적으로 작성한 코드가 잘 작성한 코드이다.

## 유형

- 완전 탐색: 모든 경우의 수를 빠짐없이 다 계산
- 시뮬레이션: 문제에서 제시하는 논리나 동작 과정을 그대로 코드로 옮김
- 좌표를 순회하며 검사하는 경우
- 범위,시간,조합에 대해 순회하며 검사하는 경우
  - 배열로 범위를 설정하고 자유자재로 검사할 수 있어야 함
  - 원형, 행렬 등 범위 초과하여 검사해야 하는 경우 범위를 확대하여 계산을 용이하게 할 수 있음.
  - 원형 데이터를 2배로 늘리면 시계/반시계 방향 모두 계산이 가능하다.

## 문제유형

- 09번: 입력값 1000이하 -> 완전 탐색(n\*\*2)
  - 모든 압축 단위에 대해 가능한 모든 문자열 압축 방법 고려
  - 기준 = 문자열[0:압축단위], 등장횟수 초기화
  - 문자열 바뀌면 압축문자열에 추가, 아니면 등장횟수 증가
- 10번: 열쇠를 회전, 이동 -> 자물쇠 충족하는지 확인
  - 열쇠, 자물쇠 크기 <20 -> 모든 원소에 접근=400연산
  - 이동, 회전 모든 경우 완전 탐색 -> n**2 * (n*3) **2 \*4 = 576만번
  - 열쇠 회전, 자물쇠 중앙 확인 함수
  - 자물쇠 3배로 키우는 트릭
  - 자물쇠 모든 위치별로 열쇠 회전, 확인
  - 일단 적용시키고, 오답일 경우 복원시키는 트릭
- 11번: 매트릭스에 뱀을 일단 이동시키고, 유효한 매트릭스면 계속 진행, 아닐경우 종료
  - 뱀의 모양, 사과 등 모양 기록할때는 좌표계 사용
  - 뱀 몸은 따로 배열에 저장
  - 이동 -> 뱀 꼬리 추가, 빈칸 -> 꼬리 삭제, 사과-> 삭제하지 않음
  - 방향 배열로 회전 구현
  - (시간, 방향)-> 따로 카운트 두어 해당 시간일때 방향 전환
- 12번: n<1000, n\*\*3으로 풀이
  - 좌표계를 모두 구성하지 않고 이차원 배열을 활용
  - 문제의 좌표계와 n\*\*2 행렬의 차이 - 행렬 모든 요소를 탐색할 필요 없이 요소 인접한 요소만 확인하면 됨
  - 우선 기둥,보 추가,삭제 하고, 조건에 맞게 좌표계 유효성 검사하여 유효한 좌표계인지 확인
- 13번: m<=13이므로, 13Cm은 100000을 넘지 않는다. 집의 개수 최대 100 이므로, 모든 m의 경우에 대해서 모든 도시 치킨 거리(집-치킨집)완전 탐색이 가능하다. O(13!/(m!_(13-m)!) _ 2n \* m) => O(13!)
  - 치킨집 목록에서 m개를 조합하고, 모든 조합에 대해 도시 치킨 거리를 구하여 최소값을 갱신한다.
  - 도시 치킨 거리는 모든 집에 대해 모든 치킨집을 돌며 최소 거리를 갱신하고 합을 더한다.
- 14번: 모든 출발점(외벽의 길이)에 대해 친구를 나열하는 모든 경우의 수 확인 O(15\*\* 2 \* 8!)
  - 모든 조합->점검 가능한지 확인하며 조합 길이 최소한으로 업데이트
  - 원형 데이터를 2배로 늘리면 시계/반시계 방향 모두 계산이 가능하다.

## 시간

- 1초에 2000만에서 1억 정도의 연산
- 보통 연산 횟수가 10억을 넘어가면 오답 판정을 받는다.
- n의 범위에 따른 알고리즘 결정
  - 500: N\*\*3
  - 2000: N\*\*2
  - 100000(1e5): N log N
  - 10000000(1e7): N
