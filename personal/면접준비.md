- 자료구조
- 알고리즘
- 개발 상식
- 경력,경험
- 회사에 대한것
- 자바스크립트
- 프론트엔드

# 전산 기초

## 개발 상식

### 객체지향

- 객체지향: 프로그램을 단순한 명령어의 집합으로 보는 것이 아니라 객체라는 기본 단위들로 나누고 이들 간의 상호 작용으로 서술하는 방식
- 객체: 하나의 변수가 데이터와 메서드를 포함하는 추상 자료형
- 추상화: 복잡한 것을 약속을 통해 이해하기 쉽게 단순화하는것
- 다형성: 자식 클래스가 고유한 특성을 가질수 있는것. 부모에게 상속받은것을 덮어쓰거나 변형할 수 있다.
- 상속: 자식 클래스가 부모 클래스의 특성과 기능을 그대로 물려받는것.
- 캡슐화: 변수와 함수를 독립적인 하나의 단위로 묶는 것. 이를 통해 정보 은닉이 가능하다.

### REST

- resource oriented architecture로 api 설계 중심에 자원이 있고 메소드를 통해 자원을 처리하도록 설계하는것
- 자원과 행위를 통해 api를 설명하는 형식
- 리소스는 명사로 표현하고 행위는 http 메서드로 표현한다.

### TDD

- 테스트를 통해 매우 짧은 개발 사이클을 가져가는 방법론으로, 새로운 기능에 대해 먼저 테스트를 작성하고 이를 만족시키는 프로그램을 작성하는 방식으로 개발한다.

### 함수형 프로그래밍

- 순수 함수를 통해 예측가능하고 단순한 프로그램을 작성하는 패러다임
- 객체지향에서 객체가 내부에 데이터를 갖는 특성으로 인해 상태를 추적하기 어려워졌고, 동시성을 처리해야하는 복잡한 생태계에서는 이것이 단점으로 대두되었다. 따라서 상태를 서술하는 객체 대신, 동작을 설명하는 함수를 통해 선언적으로 개발하는 방법론이다.

### MVC

- 소프트웨어 디자인 패턴중 하나로, 정보가 사용자에게 제공되고 사용자로부터 응답을 받는 방식에서 정보의 내부 표현을 분리하기 위해 사용된다.
- mvc는 모델, 뷰, 컨트롤러의 약자로 이러한 상황을 핸들링하는 세가지 주체로 나누어 프로그램을 작성하는 방식이다.
- 모델은 데이터 구조를 말하고 뷰는 사용자에게 보여지는 정보 구조를, 컨트롤러는 이 둘을 중재하기 위해 입력을 받아 전달하는 프로그램이다.

## 자료구조

### 배열 vs 연결리스트

- Array vs Linked list를 비교해서 설명해주세요
  - 배열과 연결리스트는 선형적 자료구조의 대표적인 유형으로, 자료구조는 크게 메모리공간 기반의 연속 방식과 포인터 기반의 연결 방식으로 나뉜다. 배열은 연속 방식의 가장 기본이 되는 자료형이며, 연결리스트는 연결 방식의 가장 기본이 되는 자료형이다.
  - 배열은 인덱스를 통해 요소에 접근할 수 있는 자료구조를 말한다.
    - 타입이 같은 데이터들을 하나로 묶기 위해 고안되었다.
    - 주요 연산시 시간복잡도는 삽입/삭제 O(n), 탐색 O(1)
  - 연결리스트는 다양한 추상 자료형 구현의 기반이 되는 자료형으로 데이터 요소의 선형 집합이며, 데이터의 순서가 메모리에 물리적인 순서대로 저장되지는 않는다. 연결 구조를 통해 동적으로 노드를 삽입하거나 삭제하기가 간편하다.
    - 주요 연산시 시간복잡도는 삽입/삭제 O(1), 탐색 O(n)
- 데이터 삽입이 많은 경우 어떤게 더 유리한지?
  - 연결리스트가 자료구조의 크기를 동적으로 할당하기 때문에 유리하다. 배열은 할당된 공간이 가득 차면 공간을 재할당해야하는데 이때 O(n)의 연산이 발생한다. 또한 삽입 연산시 최악의 경우 나머지 요소도 옮겨야 하기 때문에 시간복잡도 O(n)이다. 반면 연결리스트는 삽입시 연결만 시켜주면 되기 때문에 시간복잡도 O(1)이고 공간의 제약도 없다.

### 스택과 큐

- 큐 스택 비교 설명하시오
  - 스택은 데이터가 후입선출로 처리되는 자료구조이다. 삽입,삭제의 주요 연산을 가지는 추상 자료구조이다. 삽입은 스택 마지막에 데이터를 추가하며, 삭제는 스택 마지막 데이터를 삭제하도록 구현된다. 구현은 배열과 연결리스트를 사용하여 구현이 가능하다.
  - 큐는 데이터가 선입선출로 처리되는 자료구조이다. 삽입,삭제의 주요 연산을 가지는 추상 자료구조이다.
- Queue는 무슨 자료구조 인가요?
- Stack은 어떤 자료구조 인가요?
- Stack 두 개를 이용하여 Queue를 구현해 보세요
  - 스택 두개를 각각 a,b라고 하면 요소를 삽입할때는 a에 삽입하고, 삭제할때는 b에 요소가 있으면 b에서 삭제하고, b가 비어있으면 a가 빌때까지 삭제하여 순서대로 b에 삽입한 후, b에서 요소를 삭제한다.
- Queue 두 개를 이용하여 Stack을 구현해 보세요
  - 큐 두개를 각각 a,b라고 하면 a를 메인 큐, b를 임시 큐로 둔다.
  - 삽입할때는 a에 삽입하고, 삭제할때는 a에 요소가 한개 남을 때까지 꺼내 b에 삽입한 다음, 한개 남은 요소를 꺼내 저장하고, b의 요소를 a로 모두 옮긴다.

### 트리

- BST는 어떤 자료구조 인가요?
  - 이진탐색트리란 모든 노드에 대하여 왼쪽 자식 노드의 값이 노드의 값보다 작거나 같고, 우측 자식 노드의 값이 노드의 값보다 큰 조건을 만족하는 트리를 말한다. 이 조건은 트리의 정렬을 보장하며, 중위순회했을때 오름차순으로 정렬된다.
  - 이진탐색트리의 최선의 경우 시간복잡도는 삽입/삭제/탐색이 O(log n)에 이뤄진다고 표현할 수 있으며 이는 트리의 높이에 비례한다.
  - 이진탐색트리의 최악의 경우 시간복잡도는 n이며 편향이진트리일때 선형 자료구조를 탐색하는 것과 시간복잡도가 같아진다.
- hashtable vs BST를 비교하여 설명해 주세요

### 힙

- Queue vs priority queue를 비교하여 설명해 주세요
  - 큐는 선입선출 자료구조로 데이터의 값이 아닌 삽입된 순서에 의해 순차적으로 나열되어 있다.
  - 우선순위 큐는 데이터의 우선순위 값의 크기에 따라 정렬을 유지하는 자료구조이다.
  - 삭제 연산을 하면 우선순위에 따라서 값이 결정된다.
  - 이러한 특성은 힙으로 구현할 수 있으며 최대힙을 이용하면 우선순위가 높은 순서대로 정렬할 수 있다.
  - 최대힙은 항상 루트는 최대값을 가지며 각 노드의 원소가 자식들의 원소보다 크다는 특성을 가진다.
  - 삽입/삭제시 트리의 특성을 만족시키기 위해 O(log n) 시간이 걸린다.
  - 삽입시 맨 우측에 요소를 삽입하고 트리의 특성을 만족시킬 때까지 부모와 위치를 바꾼다.
  - 삭제시 루트 요소를 삭제하고 마지막 원소를 루트로 가져온 후, 트리의 특성을 만족하도록 자식 노드와 교환해 나간다.
  - 노드 i의 부모 노드 인덱스는 i//2
  - 노드 i의 왼쪽 자식 노드 인덱스는 2i
  - 노드 i의 오른쪽 자식 노드 인덱스는 2i+1
  - 최소힙도 값의 비교가 반대인 것을 제외하면 완전히 동일하게 작동한다.

### 해시 테이블

- hashtable는 어떤 자료구조 인가요?
  - 키를 값에 매핑할수 있는 구조인 연관 배열 추상 자료형을 구현하는 자료구조다.
  - 공간을 더 사용하여 시간복잡도의 성능을 취한 자료구조로 삽입,삭제,조회 연산이 상수 시간 복잡도이다.
  - 키와 값을 해시테이블에 삽입할때는 해시 함수를 통해 키의 해시 코드를 계산하고, 해시 코드를 이용해 배열의 인덱스를 구해 값을 삽입한다.
  - 이때 다른 키가 같은 인덱스를 바라보게 되면 해시 충돌이 발생한다.
- hashtable의 collision이 발생하면 어떻게 되나요? 해결방법엔 뭐가 있을까요?
  - 개별 체이닝
    - 같은 인덱스를 연결리스트로 연결하는 기법
    - 최악의 경우 시간복잡도가 n으로 오르게 된다.
  - 오픈 어드레싱
    - 탐사를 통해 다음 빈 공간을 찾는 방식이다. 이때문에 모든 원소가 자신의 해시값과 일치하는 주소에 저장된다는 보장은 없다.
    - 데이터가 한쪽으로 쏠리는 문제점이 발생할 수 있다.

### 그래프

## 네트워크

### HTTP vs HTTPS

- http(hyper text transfer protocol): 서버 클라이언트 모델을 따라 데이터를 주고 받기 위한 프로토콜. 인터넷에서 하이퍼텍스트를 교환하기 위한 통신 규약
  - 상태를 가지고 있지 않은 stateless 프로토콜이며 method, path, version, headers, body 등으로 구성된다.
  - 암호화 되지 않은 평문 데이터를 전송하는 프로토콜로 제 3자가 정보를 조회할 수 있다.
- https(hyper text transfer protocol secure): http에 데이터 암호화가 추가된 프로토콜.
  - 네트워크 상에서 중간에 제3자가 정보를 볼수 없도록 암호화를 지원하고 있다.
  - http는 ssl과 통신하고 ssl이 tcp와 통신한다.

### GET POST

- get: 요청하는 데이터가 http request message의 헤더에 url이 담겨서 전송된다. 때문에 url상에 ?뒤에 데이터가 붙어 리퀘스트를 보내게 되는것이다. 이러한 방식은 url에 담겨서 전송되기 때문에 데이터의 크기가 제한적이다. url에 데이터가 그대로 노출되므로 보안이 필요한 데이터에 대해서는 적절하지 않다.
- post: http request message의 바디 부분에 데이터가 담겨서 전송된다. 때문에 데이터의 크기가 더 크고 보안면에서 get방식 보다는 낫다. 서버의 값이나 상태를 변경 또는 추가하기 위해서 사용된다.

### 웹 통신의 큰 흐름

### 브라우저에 주소를 입력하면 어떤 일이 벌어지는가?

- 브라우저의 핵심 기능은 필요한 리소스를 서버에 요청하고 서버로부터 응답을 받아 브라우저에 시각적으로 렌더링하는 것이다. 즉 렌더링에 필요한 리소스는 모두 서버에 존재하므로 필요한 리소스를 서버에 요청하고 서버가 응답한 리소스를 파싱하여 렌더링하는 것이다.
- 서버에 요청을 전송하기 위해 브라우저는 주소창을 제공한다. 브라우저의 주소창에 url을 입력하고 엔터 키를 누르면 url의 호스트 이름이 dns를 통해 ip주소로 변환되고 이 ip 주소를 갖는 서버에게 요청을 전송한다.
- 주소창에 주소를 입력하고 엔터 키를 누르면 프로토콜+호스트로 구성된 url에 의한 요청이 서버로 전송된다. 서버는 루트 요청에 일반적으로 index.html을 응답한다.
- 이후 브라우저의 렌더링 엔진이 2진수 형태로 받은 응답을 해석하여 렌더링을 수행한다. [브라우저의 렌더링 원리](#브라우저의-동작-원리)

## 운영체제

### 프로세스, 스레드

### 스케쥴러

### 세마포어

## 데이터 베이스

## 알고리즘

### DFS/BFS

- n개의 Hanoi 탑을 1번 막대에서 3번 막대로 모두 옮기는 알고리즘을구현해주세요.
  - 하노이탑은 모든 원반에 대해 자신보다 작은 원반이 위에 있어야 한다는 규칙을 가진다.
  - 하노이탑을 다른 기둥으로 옮기기 위해서는 맨 아래 원반을 목적지에 옮겨야 한다.
  - 이를 위해서는 바로 위의 모든 원반들을 임시 기둥에 옮겨야 한다.
  - 그 후 맨 아래 원반을 출발지에서 목적지로 옮긴다.
  - 맨 아래 원반을 목적지에 옮겼다면 그 위의 모든 원반을 임시 기둥에서 목적지로 옮겨야 한다.
  - 모든 원반에 대해서 이 절차자 지켜져야 하고 이는 n~0, f(n-1)f(n)f(n-1) 점화식으로 표현할수 있다.
  - hanoi(n, from, to, temp) 로 정의한다면, 재귀 호출하며
  - n==0 return
  - hanoi(n-1, from, temp, to)
  - result.push(n)
  - hanoi(n-1, temp, to, from)
- Fibonacci 수열의 n번 째 값을 구하는 알고리즘을 구현해주세요.
  - 피보나치는 점화식으로 표현할 수 있다.
  - f(1) = 1, f(2) = 1
  - f(n) = f(n-1)+f(n-2)
  - 점화식은 재귀함수로 표현하면 직관적으로 표현할수 있다.
  - 다만 피보나치 재귀함수로 구현하면 2번씩 트리의 높이만큼 연산이 발생하기 때문에 시간복잡도가 2\*\*n승까지 올라간다.
  - 따라서 다이나믹 프로그래밍의 메모이제이션을 적용하여 바텀업으로 최소 함수부터 n에 도달할때까지 반복문으로 해결하는 것이 효율적이다. 이때 시간복잡도는 n이다.

### 정렬

- Bubble sort 코드를 작성하고 설명해 주세요.
  - 서로 인접한 두 원소의 대소를 비교하고 조건에 맞도록 스왑한다.
  - 원소마다 자신을 제외한 모든 원소와 비교를 진행하며, 한번 순회하고 나면 앞에서부터 하나씩 원소를 제외하고 다시 비교를 시작한다.
  - 시간복잡도는 n^2이다.
  - 공간복잡도는 n이다.
- Insertion sort 코드를 작성하고 설명해 주세요.
  - 2번째 요소부터 시작하여 그 앞의 원소들과 비교하여 삽입할 위치를 결정해가는 알고리즘이다.
  - 현재 요소와 앞의 요소를 비교하여 더 작으면 교환하고, 크면 멈춤으로써 위치를 고정한다.
  - 이를 인덱스 끝까지 반복한다.
- Selection sort 코드를 작성하고 설명해 주세요.
  - 해당 순서에 원소를 넣을 위치를 결정하고, 어떤 원소를 넣을지 선택하는 알고리즘이다.
  - 주어진 배열 중 최소값을 찾는다.
  - 그 값을 맨 앞에 위치한 값과 교체한다.
  - 맨 처음 위치를 뺀 나머지 배열을 같은 방법으로 교체한다.
  - 위의 과정을 배열을 다 탐색할때까지 반복한다.
  - 시간복잡도는 최선의 경우 n, 최악 n^2
    - 최선의 경우는 정렬된 경우이다.
  - 공간복잡도는 n이다.
- Quicksort 코드를 작성하고 설명해 주세요.
  - 분할 정복 방법을 통해 주어진 배열을 정렬하는 알고리즘이다.
  - 피벗을 고르고 피벗 앞에는 작은 원소들이, 뒤에는 큰 원소들이 위치할 수 있도록 피벗을 기준으로 둘로 나눈다. 분할을 마친 피벗은 더이상 움직이지 않는다.
  - 이를 재귀적으로 반복한다.
  - 최선의 시간 복잡도는 n log n이다. 피벗을 기준으로 반씩 나누기 때문에 순환 호출의 깊이가 log n이기 때문이다. 이때 전체 배열을 비교하기 때문에 각 순환 호출 단계의 비교 연산은 n이 발생한다. 따라서 n번의 비교 연산을 순환 호출의 깊이만큼 반복한다고 볼 수있다.
  - 피벗 값이 최소나 최대로 지정되어 파티션이 나누어지지 않았을때 n^2의 시간복잡도를 가진다. 정렬된 경우이다.
  - 퀵소트 성능을 향상시키려면 피벗이 잘 설정될 수 있도록 해야한다.
  - 피벗을 설정하는 방법에는 3 원소를 선택한 중간값을 취하는 방법, 랜덤하게 원소를 택하는 방법 등이 있다.
- Merge sort 코드를 작성하고 설명해 주세요.
  - 요소를 쪼갠 후 다시 합병시키면서 정렬해가는 알고리즘이다.
  - 요소를 쪼갤수 없을 때까지 쪼갠 후 두 요소를 비교하면서 정렬하는데, 두 영역은 각 영역에 대하여 정렬되어 있으므로 단순히 두 배열을 순차적을 비교하면서 정렬할수가 있다.
  - 병합정렬은 순차적인 비교로 정렬을 진행하므로 연결리스트의 정렬이 필요할때 사용하면 효율적이다.
  - 분할 정복의 한 종류로서 안정정렬에 속한다.
  - 시간복잡도는 평균 최선 최악 n log n이다.
  - 별도의 배열을 사용하여 추가 공간을 사용한다는 단점이 있다.
- 가장 빠른 정렬알고리즘은 무엇인가요?
  - 병합 정렬은 항상 n log n을 보장해준다. 정렬된 경우에는 삽입정렬과 선택정렬이 n으로 가장 빠르다.
- Tim sort에 대해서 설명해 주세요.

### 탐색

- binary search 알고리즘을 화이트보드에 작성하며 설명해주세요.
  - 정렬된 자료에 대해서 이진 탐색을 수행할 수 있다.
  - 대상 배열의 중간값을 정하고, 찾고자 하는 값이 중간값보다 크면 우측에 대해서만, 작으면 좌측에 대해서만 탐색을 반복하면 된다.
  - 최대 log n에 탐색이 종료된다.
  - left <= right동안 반복

# 언어

## 자바스크립트

### const let var

- var
  - 함수 레벨 스코프를 따른다. 따라서 함수 밖에 선언한 변수는 모두 전역변수가 된다.
  - 중복 선언이 가능하다.
  - 변수 호이스팅에 의해 변수 선언문 이전에 참조할 수 있다.
- let
  - 블록 레벨 스코프를 따른다.
  - 선언문 이전에 참조할 수 없도록 tdz가 발생한다.
  - 전역 객체의 프로퍼티가 되지 않는다.
- const
  - 재할당이 허용되지 않는다.
    - 재할당이 허용되지 않는 것이기 때문에 객체를 할당하면 객체의 값을 변경하는 것은 가능하다.
  - 블록 스코프를 따른다.

### 이벤트 루프

- 브라우저는 자바스크립트 엔진을 포함하여 다른 부분들도 제공하고 있는데, 이중에는 자바스크립트의 동시성을 지원하기 위한 이벤트 루프도 있다.
- 자바스크립트 엔진은 하나의 실행 컨텍스트 스택을 가지기 때문에 싱글 스레드로 동작한다. 때문에 동기적으로 실행하면 blocking이 발생하는 타이머 함수, http 요청, 이벤트 핸들러 등 비동기 처리 방식으로 동작하는 함수들은 이벤트 루프에서 처리한다.
- 이벤트 루프는 콜 스택과 태스크큐를 반복적으로 확인하며 콜 스택이 비어있으면 태스크 큐에 대기중인 함수를 순차적으로 콜스택으로 이동시키며 콜스택에 이동된 함수는 실행된다.
- 태스크 큐는 비동기 함수의 콜백 함수 또는 이벤트 핸들러가 일시적으로 보관되는 영역이다.
- settimeout는 콜백 함수를 호출 스케쥴링하고 타이머가 만료되면 콜백 함수가 태스크큐에 푸시된다.

### 호이스팅

- 모든 선언문이 소스코드의 상단으로 끌어올려진것처럼 작동하는 자바스크립트의 특징이다.
- 모든 소스코드는 평가 과정과 실행 과정으로 나누어 처리되는데 평가 과정에서 실행컨텍스트를 생성하고 선언문만 먼저 실행하여 생성된 변수나 함수를 실행컨텍스트의 스코프에 등록하기 때문에 발생하는 현상이다.

### 클로저

- 클로저는 외부 함수보다 중첩 함수가 더 오래 유지되는 경우 중첩 함수는 이미 생명주기가 종료한 외부 변수를 참조할 수 있는데 이러한 중첩함수를 말한다.
- 함수가 종료되면 함수의 실행 컨텍스트가 실행 컨텍스트 스택에서 제거되지만 함수의 렉시컬 환경까지 즉시 소멸하는 것은 아니다. 종료된 함수의 렉시컬 환경이 중첩 함수의 내부 슬롯에 의해 참조되고 있고 중첩 함수가 외부로 반환되어 있다면 가비지 컬렉션의 대상이 되지 않아 메모리에 존재하게된다.
- 클로저에 의해 참조되는 상위 스코프의 변수를 자유 변수라고 한다. 클로저란 함수가 자유변수에 대해 닫혀있다는 의미이다. 즉 자유변수와 묶여있는 함수라고 할수 있다.
- 클로저는 상태를 안전하게 변경하고 유지하기 위해 사용한다. 상태가 의도치 않게 변경되지 않도록 상태를 안전하게 은닉하고 특정 함수에게만 상태 변경을 허용하기 위해 사용한다. 자바스크립트에서 private같은 접근제한자를 제공하지 않기 때문에 유용하게 사용된다.
- 중첩함수를 반환하여 외부함수의 지역변수를 상태로 활용하는 클로저는 고차함수 형태로 활용된다.

### this

- this는 객체의 프로퍼티나 메서드를 참조하기 위한 자기참조 변수이다. 생성자 함수를 통해 인스턴스를 생성할 때, 아직 생성되지 않은 인스턴스를 가리키기 위한 특수한 식별자이다.
- this 변수는 함수를 호출할때 암묵적으로 함수 내부에 전달되며, 함수가 선언될 때가 아닌 호출될때 this가 결정, 즉 바인딩된다.
- 이러한 이유는 자바스크립트에서 함수는 형식이 결정되어 있지 않다. 즉 생성자 함수와 일반함수, 메서드가 형식상으로 구분되어 있지 않다. 다만 함수가 어떻게 호출되느냐에 따라 결정되는데 이러한 특성때문에 함수를 호출한 맥락에 따라 일반함수, 메서드, 생성자 함수로 호출했는지 결정되고 this가 결정된다. 이를 바꿔 말하면 this는 생성자 함수나 메서드로 호출된 경우에만 의미가 있고 일반함수내에서는 의미가 없다.
- 생성자 함수로 호출한 함수 내부의 this는 생성자 함수가 생성할 인스턴스가 바인딩된다.
- 메서드로 호출되면 메서드를 호출한 객체가 바인딩된다.
- 일반 함수로 호출되면 전역 객체가 바인딩된다.
- apply/call/bind 메서드를 이용해 함수를 간접 호출하게되면 첫번째 인수로 this를 전달할 수 있다. 이는 일반함수로 호출시 this에 전역객체가 바인딩되기 때문에, 메서드 내부에서 호출한 중첩함수 혹은 콜백함수의 this가 외부함수의 this와 일치하지 않는 등의 현상을 수정할때 사용할수 있다. 이렇게 외부 함수의 this를 그대로 따라야 하는 경우에는 es6에서 도입된 화살표함수를 사용하는 것이 적절하다.
- 화살표함수 내부의 this는 렉시컬 this로 this 바인딩을 갖지 않으며, this 참조시 스코프 체인에 따라 외부 함수의 this를 참조하게 된다.

### promise

- 프로미스는 전통적인 비동기 처리를 위한 하나의 패턴인 콜백 함수의 문제점인 콜백 헬과 에러 처리의 한계로 인해 도입된 비동기 처리 시점을 명확하게 표현할 수 있는 문법이다.
- 콜백 패턴에서 에러를 처리할 수 없는 이유는 자바스크립트에서 에러는 호출자 방향으로 전파되는데, 콜백 함수에서 에러가 발생한 시점에는 콜백 함수의 상위 함수는 이미 종료되어 실행 컨텍스트 스택에서 제거된 이후이기 때문에 에러는 캐치될수 없기 때문이다.
- 프로미스는 프로미스 생성자함수를 통해 생성되며 인수로 resolve와 reject함수를 받는다. 프로미스는 비동기 처리 상태 정보를 가지며, 이는 pending, fulfiled, rejected로 나뉜다. 상태는 비동기 처리가 수행되면 pending에서 fulfiled 혹은 rejected로 변경되며 한번 변경된 상태는 다시 변경될 수 없다. 상태가 변경되면 resolve, reject 함수에 처리 결과를 전달하며 호출한다.
- 프로미스는 프로미스 처리 결과를 연속적으로 관리하기 위한 메서드를 제공한다.
  then, catch, finally는 항상 프로미스를 반환하고, 이 메서드를 통해 프로미스 체이닝을 구현할수 있다.
- then은 resolve, reject함수를 인수로 받으며 각각 비동기 처리 결과에 따라 실행된다. then 메서드로 에러를 처리하면 첫번째 콜백에 대한 에러는 캐치할 수 없기 때문에 catch 메서드로 에러를 처리하는 것이 권장된다.
- catch는 프로미스가 rejected인 경우에 호출된다.
- filnally는 프로미스의 성공/실패와 상관없이 무조건 한번 실행된다. 성공 여부와 상관없이 수행해야 할 내용이 있을 때 유용하다.

### async/await

- 비동기 처리를 마치 동기 처리저럼 동작하도록 구현하기 위한 문법이다.
- async 키워드로 함수를 비동기함수로 정의할수 있으며, 항상 프로미스를 반환한다.
- await 키워드는 반드시 async 함수 내부에서 사용해야 하며 프로미스가 처리될때까지 기다렸다가 resolve한 결과를 반환한다. 이는 비동기 함수를 마치 동기적으로 사용할수 있게 해주며 비동기 함수를 직렬적으로 구성할때 유용하다. 반면 함수를 병렬적으로 호출할때는 promise.all메서드를 통해 구현하는것이 좋다.
- async함수에서의 에러처리는 try, catch문을 사용할 수 있다. 콜백 함수를 인수로 받는 비동기 함수와는 달리 프로미스를 반환하는 async 함수는 명시적으로 호출할 수 있기 때문에 호출자가 명확하다. async 함수 내에서 catch문을 사용해 에러처리를 하지 않으면 async 함수는 발생한 에러를 reject하는 프로미스를 반환한다.

### react vs vue

##### vue

- 반응형, 값 대입만으로 변경
- 양방향바인딩
- html
- 자유도낮음
- 서드파티 의존도 낮음
- 러닝커브 낮음

##### react

- 함수형, setState, pure, mapstatetoprops
- 단방향바인딩
- jsx
- 자유도 높음
- 서드파티 의존도 높음
- 러닝커브 보통

##### 차이점

- vue와 리액트의 가장 큰 차이점은 마크업과 로직을 어떻게 결합시키느냐 하는 관점이라고 생각한다. vue는 기존 html로 코드를 작성하는 것과 스타일이 비슷하다. 마크업과 로직을 템플릿과 스크립트라는 태그로 분리해서 작성하도록 스타일이 규정되어있다. 반면 리액트는 컴포넌트 통해 마크업과 로직을 느슨하게 결합하고, jsx 객체를 통해 가상 돔을 업데이트하도록 한다. 이 결합방식에서 오는 차이가 자유도에 큰 차이로 느껴졌고 개인적으로는 뷰의 형식을 지켜야하는 부분이 답답하게 느껴졌다. 뷰를 더 깊게 알았다면 자유자재로 모듈화를 할수 있었겠지만 그런 정보에 접근하는것도 어렵게 느껴졌었다.

### react 상태관리

# 분야

## 프론트엔드

### 브라우저의 동작 원리

1. 브라우저의 요청에 의해 서버는 html 파일을 읽어들여 2진수 형태로 응답한다.
2. 브라우저는 서버가 응답한 2진수 형태의 html 문서는 meta 태그에 지정된 인코딩 방식을 기준으로 문자열로 변환된다.
3. 문자열로 변환된 html 문서를 읽어들여 문법적 의미를 갖는 코드의 최소 단위인 토큰들로 분해한다.
4. 각 토큰들을 객체로 변환하여 노드들을 생성한다. 토큰의 내용에 따라 문서노드, 요소노드, 어트리뷰트노드, 텍스트노드가 생성된다.
5. 요소의 부자관계를 반영하여 모든 노드들을 트리 자료구조로 구성한다. 이 자료구조를 DOM이라고 한다.

- 즉 DOM은 html 문서를 파싱한 결과물이다. 이는 브라우저의 렌더링 엔진에서 수행된다.
- 렌더링 엔진은 html을 처음부터 한줄씩 순차적으로 파싱하여 DOM을 생성해 나간다. 그러다가 css를 로드하는 태그를 만나면 돔 생성을 일시 중단하고 css를 html과 동일한 파싱 과정(바이트->문자->토큰->노드->CSSOM)을 거쳐 CSSOM을 생성한다. 파싱을 완료하면 DOM트리 생성을 재개한다.
- 생성된 DOM과 CSSOM은 렌더 트리로 결합된다. 브라우저 화면에 렌더링되는 노드만으로 구성된다. 렌더트리는 요소의 레이아웃을 계산하는데 사용되며 브라우저 화면에 픽셀을 렌더링하는 페인팅 처리에 입력된다. 레이아웃이 변경될 경우 다시 실행된다.
- DOM은 HTML문서의 구조와 정보뿐 아니라 요소를 변경할 수 있는 프로그래밍 인터페이스로서 DOM API를 제공한다. 자바스크립트에서 DOM API를 사용하면 이미 생성된 DOM을 동적으로 조작할 수 있다.
- 렌더링 엔진이 html을 파싱하다가 script 태그를 만나면 돔 생성을 일시 중단하고 자바스크립트 엔진에 제어권을 넘긴다.
- 자바스크립트 엔진은 자바스크립트 코드를 파싱하여 추상 구문 트리를 생성한다. 그리고 추상 구문 트리를 기반으로 인터프리터가 실행할 수 있는 바이트코드를 생성하여 실행한다.
- 만약 자바스크립트 코드에 DOM이나 CSSOM을 변경하는 DOM API가 사용된 경우 DOM, CSSOM이 변경된다. 이는 다시 렌더트리로 결합되고 렌더 트리를 기반으로 레이아웃과 페인트 과정을 거쳐 브라우저의 화면에 다시 렌더링한다. 이를 리플로우, 리페인트라 한다.

### DOM

- DOM은 html 문서의 계층적 구조와 정보를 표현하며 이를 제어할 수 있는 api를 제공하는 트리 자료구조다.
- HTML 요소는 렌더링 엔진에 의해 파싱되어 dom을 구성하는 요소 노드 객체로 변환된다. 요소 노드 객체는 부자 관계를 가지며 이는 DOM 트리에 반영된다.
- 노드 객체에는 여러 타입이 있으며 이 역시 객체이므로 프로토타입에 의해 상위 요소의 인터페이스의 기능을 사용할 수 있다.
- 노드 객체는 이벤트 타겟, 노드 인터페이스를 상속받으며 이를 통해 dom api를 상속받아 이벤트에 관련된 기능을 사용할 수 있고 트리를 탐색하거나 dom을 조작할 수 있다.

### CORS

- 대부분의 브라우저는 보안상의 이유로 same origin policy, 같은 오리진에서만 데이터를 송수신할 수 있다.
- origin: 프로토콜 + 호스트, 포트
- 하지만 클라이언트도 서버를 별도로 구축하게 되면서 타 도메인간 자원 공유가 필요해졌다.
- cors(cross origin resource sharing)는 타 도메인간에 자원을 공유할수 있게 해주는 웹 표준이다. 웹 브라우저가 사용하는 정보를 읽을 수 있도록 허가된 출처 집합을 서버에게 알려주도록 허용하는 특정 HTTP 헤더를 추가함으로서 동작한다.
- 서버는 요청을 확인해 화이트리스트에 설정된 허용할 오리진이면 데이터 송수신을 허가한다.
- preflight request
  - 실제 요청을 보내도 안전한지 판단하기 위해 preflight 요청을 먼저 보내는 방법
  - put, delete의 경우 옵션메서드로 cors인지 한번더 확인
- 쿠키, authorization headers에 jwt 보내서 추가 인증 하기도 함

### xss, csrf

- xss가 사용자가 웹사이트를 신용하는 점을 노린 것이라면, csrf는 서버가 사용자를 신용하는 점을 노린 것이다.
- xss는 관리자가 아닌 이가 웹사이트에 악성 스크립트를 삽입할 수 있는 취약점으로 발생되는 공격이다. 공격자가 악성 스크립트가 포함된 게시글을 웹사이트에 게시하면 이 글에 접근한 사용자의 브라우저에서 악성 스크립트가 실행되므로 공격이 이루어진다. 주로 사용자의 정보(쿠키, 세션 등)를 탈취하거나 비정상적인 기능을 수행하게 한다. 사용자의 입력값을 검증하지 않아서 발생하는 취약점이다.
- csrf는 서버가 정상적인 경로를 통한 요청과 비정상적인 경로를 통한 요청을 구분하지 못하는 취약점으로 발생되는 공격이다. 공격자가 악성 스크립트가 포함된 게시글을 웹사이트에 게시하면 이 글에 접근한 사용자는 자신의 권한으로 서버에 조작된 요청을 하게 되고 서버에 공격이 이루어진다. 이를 통해 사용자는 자신이 원하지 않는 요청(비밀번호 변경 등)을 하게 된다.

### 크로스 브라우징

### ssr vs csr

- 클라이언트사이드 렌더링

  - 사용자의 행동에 따라 필요한 부분만 다시 읽어들이기 때문에 서버측에서 렌더링하여 전체 페이지를 다시 읽어들이는 것보다 빠른 인터렉션을 기대할 수 있다.
  - 모든 리소스를 읽어들이고 화면을 그려야 하기 때문에 초기 구동 속도가 느리다.
  - 검색 엔진 최적화의 문제가 있다. 웹 크롤러 봇들이 자바스크립트 파일을 실행시키지 못하기 때문이다.

- 서버사이드 렌더링
  - 검색엔진 최적화에 문제가 없다.
  - 초기 구동 속도가 빠르다
  - 사용자 인터렉션시 서버에 요청을 보내서 해결해야 하기 때문에 느리다.

# 개발 외적인 부분

## 나

### 지원동기

- 왜 이 직업을 원합니까?
  - 대학에서 미디어아트를 전공하며 미디어 파사드나 vr, 아두이노로 로봇 등을 만들었는데 뭔가를 만드는 것은 좋아했지만 표현하고 싶은 것이 없어 방황을 많이 했었다. 뒤늦게 작품보다는 그것을 표현하는 매체 자체에 흥미를 느꼈다는 것을 알게되었고 예술이라는 컨텐츠를 담는 매체를 만드는 일을 해보고자 했지만 직업적으로 진출하는데 어려움이 있었다. 그때쯤 개발이라는 분야가 떠오르고 있었고 컴퓨터는 대학에서 교양 수업으로 배운것이 다였지만 한번쯤은 도전해보고 싶다는 마음이 들어 학원에서 공부를 하게 되었다. 이후 운좋게 회사에 입사하고 실무를 하면서 이 일이 재밌다고 느꼈고 기획이라는 큰그림을 코드 한줄이라는 단위로 쪼개 현실화하는 것에서 굉장한 매력을 느꼈다. 동시에 실무부터 배웠다보니 기반 지식에 대한 궁금증이 커져 평소 부족하다고 느꼈던 부분들을 채우기 위해 쉬는 시간을 갖고 하고싶은 공부를 실컷 하면서 더욱 이 분야에 대해 진심이라는 것을 알게 되었다. 개발이라는 분야가 떠오르지 않았다면 이 분야를 생각해보지 못했을텐데 덕분에 적성을 찾게 되어 다행이라는 생각도 들었다. 기반 지식과 실무 지식을 응용해 생산성을 창출할 수 있다는 점이 이 직업의 최대 매력이라고 생각한다.
  - 소프트웨어 산업이 커짐에 따라 윤리적인 부분도 중요한 이슈로 대두되는데, 휴먼스케이프의 비전은 데이터의 순기능이라고 생각되어 굉장히 멋있게 보았다. 적은 비율도 모집단을 글로벌 데이터로 확대하면 엄청난 데이터가 되고 이를 하나의 시스템으로 묶는 것은 굉장한 잠재력이 있는 분야라고 생각된다. 또한 건강은 사람들의 관심이 모이는 분야이기 때문에 매력적인 도메인이다. 저는 사람들의 삶을 좋게 만드는 개발자가 되고 싶기 때문에 헬스 케어 도메인을 공부하고 싶다. 소액이지만 HUM코인을 통해 주주가 되었다.
- 자기소개 부탁드려요
  - 안녕하세요. 칠전팔기 개발자 이다래 입니다. 무엇이든 방법은 존재한다는 믿음을 가지고 제가 내릴수 있는 최선의 결정이 무엇일지 고민합니다. 여러 사람들의 니즈속에서 가장 많은 만족을 이끌어낼때 보람을 느낍니다. 저에게 주어진 제안사항을 꼼꼼하게 분석하는 편입니다. 개발을 통해 무에서 유를 창조하는 과정에서 재미를 느끼며, 개발을 더 잘하기 위해 꾸준히 공부하는 습관을 가지고 있습니다. 실무에서는 주로 신사업에 배치되어 다이어트 코칭 앱의 초기 어드민 사이트 구축과 외주에서 자바 스프링 부스트로 구축되어있던 온라인 실시간 강의 사이트를 회사 소유로 새로 구축하는 일을 했습니다. 개인 프로젝트로 혼자서 기획과 개발을 한 점심메뉴 선정을 돕는 서비스 오늘 뭐먹지를 진행했습니다. 적성을 찾기 위해 긴 방황을 했지만 개발만큼 재미있고 흥미를 느낀 분야는 찾지 못했습니다.
- 회사를 그만둔 이후에 무엇을 하며 지내셨나요?
  - 자바스크립트 공부와 개인 프로젝트 업데이트를 진행하였고 알고리즘 공부와 컴퓨터 공학 스터디를 하고 있습니다. aws에서 진행하는 멘토링 프로그램에 참여하고 있습니다.

### 어떻게 일하는가

- 당신이 풀었던 문제 중 힘들었던 문제는?
  - 사이드 프로젝트 중 서버를 배포하는 과정에서 라이브러리 호환성으로 어려움을 겪었다. 사이드 프로젝트를 구현하고 싶어 파이썬을 처음 배워 만들었는데 어떤 특정 라이브러리는 배포 환경에서 구동하는 버전과 파이썬에서 설치하는 버전이 달라 빌드팩으로 호환되는 버전을 설치할수 있도록 설정해 주어야 했는데 이부분의 이유를 알기까지 오래 걸렸다. 이때 빌드 로그를 보는 방법을 배우게 되었다.
  - 사이드 프로젝트 중 소셜 로그인을 구현하는 중 oauth 제공자가 발급하는 토큰과 장고에서 발급하는 토큰을 혼동해 어려움을 겪었다. oauth에는 사용자 인증을 하고 로그인은 장고 서버에서 사용하는 토큰을 발급해 응답할수 있도록 해결했다. 이때 토큰의 발급 주체와 해석하는 주체가 동일해야 한다는 것을 알게되었다.
- 프로젝트 오늘뭐먹지에 대해 설명해주세요
  - 직장인들의 점심메뉴 선정 시 발생하는 커뮤니케이션을 돕는 서비스다. 매일 점심시간마다 메뉴를 선정하기 위해 한명 한명 먹고싶은 메뉴를 묻는 과정이 번거롭게 느껴졌다. 그 과정을 간소화, 자동화하는 서비스를 만들어보고 싶었다.
  - 이를 위해서 문제 정의는 점심메뉴를 정하기 위해 조직 구성원들은 서로 비슷한 질문과 답변을 반복적으로 주고 받아야 한다는 것으로 정의했다.
  - 이에 대한 해결책으로 질문을 메뉴 제안 형식으로 만들고 답변은 이를 수락 혹은 거절하는 것으로 단순화했다. 이때 우리가 점심시간에 하는 행동을 생각해 보았을때 조직 내 모든 사람에게 같이 먹자고 제안하는 경우와 평소 먹는 사람들에게 투표를 받는 두가지 시나리오로 나누어 구성해서, 메뉴 제안 조직 구성원 모두와 소그룹으로 대상을 두가지로 분리했다.
  - 메뉴 제안은 식당 이름과 간단한 메시지만 입력하면, 식당 이름을 기준으로 카카오맵에서 회사 근처의 맛집을 검색해 관련 정보를 링크로 확인할수 있도록 하여 정보를 직접 입력하지 않아도 되도록 했다.
  - 식당 이름은 회사와 연결되어있어 회사내 사람들이 리뷰를 남길수 있도록 되어 있으며, 식당 정보를 조회할때 남긴 리뷰를 확인할 수 있도록 했다.
  - 메뉴와 소그룹에 초대와 알림 기능을 제공한다.
  - 추후에 조직 별로 모인 맛집 정보들을 통계내고 가공하여 사용자에게 제공하는 방향으로 만들어갈 예정이다.
- 큰 도전에 직면한 적은?
  - 사이드프로젝트를 개발할때 그동안의 개발 경험에서 아쉬웠던 점을 개선하고 발전할 수 있는 기회로 삼고 싶었다. 아쉬웠던 점으로 기능이 추가될때마다 개별적으로 추가하는 방식으로 진행하다 보니 시간이 갈수록 복잡도가 높아졌던 점을 꼽았다.
  - 해결책으로는 컴포넌트를 UI요소와 특정 데이터를 표현하는 요소로 나누어 컴포넌트의 의존성을 낮추어 변경에 유연함을 도모했다. UI컴포넌트에 도메인 맥락이 섞이면 조건문이 발생하고 추상화되지못한 컴포넌트가 된다. 그렇다고 재사용성이 높은 도메인 코드를 반복해 작성하는 것도 비효율적이기 때문에 이를 따로 분리하도록 생각했다. UI컴포넌트와 도메인 컴포넌트를 조합하는 방식으로 구성했다. 또한 컴포넌트를 설계할때 이 컴포넌트가 어떻게 사용되어야 하는지 먼저 정의하고 UI요소와 데이터 기반요소를 정리하고 분리한 후에 개발을 진행했다.
- 최고의/최악의 디자인을 본 적이 있는가?
  - 좋은 디자인: 되는시간
    - 개발자분께서 사용하시는 것을 보고 서비스를 접하게 되었는데 특정한 문제를 해결하는 서비스는 사용법을 ux로 잘 풀어내는 것이 중요한데 이를 군더더기 없이 쉽게 사용할수 있도록 구성되어있어 인상적이었다.
    - 슬랙: 검색 기능이 잘되어있고 사용자가 커스텀할수 있는 부분이 많아서 편리했다. 로딩 인디케이터가 과하지 않으면서도 확실하게 구현되어있어 좋았다.
    - 게더타운: 커스텀 할수 잇는 부분이 많고 많은 사용자가 동시접속하더라도 영상 공유가 매끄럽게 이뤄지는 점에서 사용성이 무척 좋았다.
  - 아쉬운 디자인: 유니와이즈
    - 인터넷 강의 사이트인데 새로고침을 누를때마다 양식 제출 확인 알럿이 떠 일일히 확인을 눌러야하며 사이트가 깜빡거려 유저 경험이 아쉬웠다. 강의 수강 시간이 측정되는 면은 좋았다.
- 무엇을 배웠는가 [job x / project y]?
- 무엇이 향상되었는가 [job x / project y]?

### 퍼포먼스를 내는가?(결과)

- 무엇이 가장 큰 도전이었는가 [job x / project y]?
  - 이전 직장에서 신규 사업에 배정되어 굉장히 짧은 기간에 웹사이트를 구축해야 하는 상황이 있었다. 저포함 신입 개발자 2명이서 프론트를 나눠서 해야하는 상황이었는데 일정이 빠듯하고 처음 다뤄보는 프레임워크였던 데다가 엔드유저에게 바로 서비스되다보니 부담감이 컸다. 결국 한달정도 야근을 하며 간신히 맞춰 냈던 기억이 있다. 코드 퀄리티는 많이 아쉬웠지만 그때의 경험이 무언가를 빠르게 만들어보고 피드백을 받아 수정하는 과정을 배울수 있어서 좋았다.
- ## 현존하는 제품을 향상시킬 수 있는 아이디어

### 어려움을 겪었는가

- 무엇이 가장 힘들었던 버그였는가? [job x / project y]?
  - 사이드 프로젝트 중 서버를 배포하는 과정에서 라이브러리 호환성으로 어려움을 겪었다. 사이드 프로젝트를 구현하고 싶어 파이썬을 처음 배워 만들었는데 어떤 특정 라이브러리는 배포 환경에서 구동하는 버전과 파이썬에서 설치하는 버전이 달라 빌드팩으로 호환되는 버전을 설치할수 있도록 설정해 주어야 했는데 이부분의 이유를 알기까지 오래 걸렸다. 이때 빌드 로그를 보는 방법을 배우게 되었다.
- 어떤 기술과 경험들이 당신의 역할에서 자산이 되었으며 그 이유는?

### 본인에 대해 잘 이해하는가

- 개인적으로 일할 때 가장 잘 일 하는가? 아니면 팀원으로서 있을 때?
  - 팀원으로 있을때가 더 능률적이었던것 같다. 혼자 하는것 보다는 같이 분담해서 하는게 장기적으로 빠르기 때문이다. 또한 정보공유하는걸 좋아해서 전 회사에서 신규 입사자가 있어 알려줘야 하는 상황이 왔을때 더 재밌게 일할수 있었던것 같다.
- 어떤 개발이 가장 즐거웠는가 [job x / project y]?

  - 개인 프로젝트를 개발하면서 기존에 아쉬웠던 점을 리스트업하고 이것을 개선하기위해 나름대로의 방안을 고민하고, 그대로 실행해볼때 가장 즐거웠다. 프론트엔드 개발은 특성상 변경이 잦을수밖에 없는데 그럴때 어떻게하면 좋을지 생각해보니 그동안은 하나의 컴포넌트가 ui도 처리하고 로직도 처리하니 변경에 유연하지 못하다는 문제점을 찾게 되었고 도메인과 ui를 분리하는 방법론을 블로그에서 보게 되었고 이를 적용시켜 ui로 추상화할수 있는 컴포넌트는 추상화하고, 세부적인 컴포넌트는 최대한 작게 나누어 도메인별로 관리하는 방법을 적용하니 일관된 스타일을 가질수 있게 되었다. 이때 컴포넌트를 추상화하는 개념을 배우게되어 재미있었다.

- 블로그 글 다시 보기

## 회사 조사하기

- 블록체인 기반 환자 네트워크를 구축하는 의료 데이터 플랫폼
- 만성질환, 난치병과 같은 환자들 건강상태를 꾸준히 기록할수 있도록 서비스를 제공하고 커뮤니티에 컨텐츠 형태로 공유된 증상과 치료일지들을 체계적으로 수집 및 정리하여 제약회사, 연구기관들과 연결시켜 연구와 신약개발이 활성화될수 있도록 한다. 이러한 과정에 환자들은 커뮤니티로부터 보상을 받을수 있고 제약회사나 연구기관들은 데이터 소스를 얻을수 있다.
- 대표 서비스: 레어노트, 마미톡
- 사업목표: 휴먼스케이프 프로젝트를 시작으로 한국은 물론 의료 서비스 및 전문적인 의료 정보에 대한 접근성이 떨어지는 동남아시아 국가로 사업확장 계획
- 의료는 블록체인과의 접점이 적지 않다. 최근 일어나는 디지털 헬스케어 혁신의 근간은 결국 데이터다. 디지털 기술의 발전은 유전정보부터 진료기록, 환자가 일상에서 스스로 만들어내는 데이터까지 건강과 관련된 모든 데이터를 양적, 질적으로 바꿔놓았기 때문이다.
- 이렇게 개인의 건강에 관한 데이터가 더 많아지고 다양해지며 질이 높아질수록 이런 데이터의 생산, 저장, 전송, 공유, 활용되는 과정에서의 소유권, 보안, 프라이버시, 무결성, 추적 가능성 등의 강화가 필요해진다. 블록체인은 데이터를 새로운 방식으로 저장하고, 위변조를 방지할수 있는 기술이므로, 의료 데이터가 새롭게 필요로하는 부분들을 충족시킬 가능성이 있다.
- 블록체인은 의료 데이터를 환자가 소유하고 주도하도록 바꿀수 있다.
- 탈중앙화된 방식으로 환자 본인이 중간 판매상 없이 의료 데이터의 활용이나 거래를 위해 블록체인을 활용할 수 있다.
- 사람들에게 건강 행동을 독려하고 이를 활용하기 위한 목적이다.
- 이러한 생태계에서는 보험사뿐만 아니라 데이터를 제공한 사용자와 개발자가 모두 보상을 받는 수익 구조를 만들수 있다.

### 스티비

- 더 잘 읽히는 콘텐츠가 더 많은 사람에게 연결되도록 합니다
- 에디터 인상적
- ui 용어 통일하는 부분 인상적
- 제플린 써서 개발하는거 어떤지 궁금
- 이메일 호환성 맞추는 블로그글 흥미롭게 봤는데, 리액트로 개발한 에디터가 이러한 스펙을 맞춘 게시글을 작성해주는건지

### 추가로 이야기하고싶은 것

- 알고리즘 테스트에서 못풀었던 문제 푼것 이야기하기

### 일하는 방식

- 과정 -> 결과

### 어떤 개발자가 되고싶은지?

- 회사에 이윤을 주는 개발자가 되고 싶습니다. 코드의 효율성이 비용과 직결된다는 것을 이해하고 있습니다. 같은 작업이라 할지라도 효율적이지 못한 코드로 수행하면 보다 높은 비용이 발생하고, 효율적인 코드로 수행하면 보다 적은 비용이 발생합니다.
- 효율적인 코드를 작성하려면 회사의 코드 컨벤션을 지켜서 동료 개발자의 생산성을 떨어뜨리지 않아야 하고, 좋은 코드를 작성하도록 개선점을 찾을 수 있어야 합니다. 코드를 개선하려면 근거가 필요하고, 그 근거는 컴퓨터 사이언스 지식과 데이터에서 나온다고 생각합니다. 근거를 제시할 수 있는 개발자가 되고 싶습니다. 이를 위해서 컴퓨터 사이언스 지식을 쌓고, 성능 측정과 분석을 공부하는 개발자가 되고 싶습니다.

## JD

자격 조건
이런 휴먼이라면 시너지를 낼 수 있어요.

• 2년 이상의 프론트엔드 개발 경력
• 스도쿠를 보면 ‘이걸 코드로 어떻게 풀지? 백트래킹?’ 이라고 생각하고 시간복잡도를 구하는 사람
• 토너먼트 경기 표를 보고 ‘참가 팀이 32팀이니 한 팀은 최대 log2(32) 번의 경기를 하겠군’ 이라고 생각하는 사람
• 미로찾기 책을 보다가 ‘더 이상 갈 곳이 없으면 다시 돌아와서 다른 길을 시도하니 depth first search네?’ 라고 생각하는 사람
• 명료하고 간결한 코드를 추구하시는 분
• 모든 개발을 좋아하지 않더라도 어떤 개발이 재미있는지 말해줄 수 있는 사람
• 커뮤니케이션에 문제가 없는 사람
• 배려 깊은 사람

우대사항
[Front-end Engineer]

• React, React Native 개발 경험이 있으신 분
• Redux, Mobx 의 차이점을 알고 왜 써야 하는지 아시는 분

3. 캐주얼 토크 - 파운더와의 1:1 대화
   휴먼스케이프의 파운더(창립 멤버)가 회사를 소개하고, 서로에 대해 편하게 대화하는 시간이에요.

4. 팀 인터뷰 - 지원 부서 구성원들과의 대화
   지원자의 경험을 바탕으로 팀원들과 함께 지원자의 직무 적합성과 일하는 방식에 관해 이야기해요. 팀 인터뷰는 캐주얼 토크와 같은 날 진행됩니다.

--

20. 당신의 꿈은 무엇인가요? 정말 솔직한 자신의 꿈을 말해주세요.

21. 이전 프로젝트에서 어떤 갈등이 있었고, 그 문제를 어떻게 해결했나요? 구체적인 사례를 들어 설명해 주세요.

22. 쿼리가 들어올 때, 어떻게 해야 효과적으로 저장할 수 있나요?

23. 이 직무를 위해 당신이 정말 이것만은 열심히 했다고 생각하는 것이 있나요? 무엇인가요?

24. 이전 직장에서 업무로 어떤 평가를 받았나요?

25. 당신의 성장 과정과 특정 기업 사이에서 연관된 부분을 발견하고, 해당 기업을 소개해보세요.

26. 기획으로 내려온 내용이 마음에 들지 않는다면, 개발자 입장에서 당신은 이를 어떻게 처리할 것인가요?

27. 지금까지 당신은 성공적인 사례만을 들어 본인을 소개했는데, 당신이 실패한 사례에 관해 얘기해 주세요. 그 경험으로 당신은 무엇을 배웠나요?

28. 자주 보는 네이버 웹툰은 무엇인가요?

29. 최근에 읽은 책은 무엇인가요?

30. 네이버 서비스 중 가장 개선하고 싶은 것은 무엇인가요?

31. 지구의 질량을 더하기만 써서 계산해 보세요.

32. ‘C언어’의 프로세스 공간에 관해 설명해 보세요.

33. 1부터 100까지 더하는 프로그램을 칠판에 작성해보세요.

34. 모바일 환경이 네이버 서비스에 어떤 영향을 미칠 것으로 예상하나요?

35. 회사가 어려우면 이직할 마음이 있나요? 이전 회사에서도 그러한 이유로 네이버에 지원하신 것 아닌가요?

36. 갑자기 준비한 PT 자료가 날아갔다거나, 데이터가 날아가는 등 위기 상황이 발생하면 어떻게 대처하실 건가요?

37. OSI 7계층이 무엇인지 설명해 보세요.

38. 소팅 알고리즘을 슈도 코드로 구현하되, 변수를 사용하지 않고 해보세요.

39. 가장 어려웠던 개발 경험은 무엇인가요?

40. 스택과 링크드리스트와 리스트의 차이점을 설명해 보세요.

41. 64비트와 32비트의 차이점은 무엇인가요?

42. 정렬 알고리즘 중 가장 빠른 방식은 무엇인가요? 그 알고리즘에 대해 설명해 주세요.

43. 앞으로 카카오톡이 어떻게 될 것 같나요?

44. 당신은 카카오 안에서 5년 후에 어떤 직급이 돼 있을까요? 또, 무슨 일을 하고 싶으신가요?

45. RESTful 은 무엇이라고 생각하시나요?

46. hashCode() 값이 모두 같다면 어떤 일이 벌어지나요?

47. 이전 업무에서 기능을 개선한 사례에 관해 설명해 주세요.

48. 왜 카카오에 오고 싶으신가요?

49. 다른 사람들은 당신을 어떤 사람이라고 생각하나요?

50. 당신이 논리적으로 문제를 해결했던 경험을 설명해 주세요.

51. 대화 로그는 얼마나 오래 서버에 저장해야 할까요?

52. 자신의 능력 개발을 위하여 어떠한 것들을 하시나요?
53. 어떠한 소프트웨어를 개발하고 싶으신가요?
